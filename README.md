# CS3388 Assignment 5
## Submitted Files
- `as5.cpp`: Main program source code.
- `TriTable.hpp`: Header with the Marching Cubes lookup tables.
- `shaders.hpp`: Header with the vertex and fragment shader code.
- `Screenshot_1.png`: Screenshot of the mesh generated by the first function in the assignment instructions (slightly different min and max values)
- `Mesh_1.ply`: PLY file for the mesh in `Screenshot_1.png`
- `Screenshot_2.png`: Screenshot of the mesh generated by the second function in the assignment instructions (slightly different min and max values)
- `Mesh_2.ply`: PLY file for the mesh in `Screenshot_2.png`
- `Screenshot_3.png`: Screenshot of the mesh generated by the default function included with the code.
## Compilation
Run `g++ -g ./as5.cpp -o ./as5 -lGL -lglfw -lGLEW` to compile. Make sure you have `TriTable.hpp` and `shaders.hpp` in the same directory as `as5.cpp`.
## Execution
Run the program as `as5 FILENAME MIN MAX STEP ISO MODE`, where:
- `FILENAME`: The name for the PLY file. Can be any string, but it's a good idea to use something ending in `.ply`
- `MIN` and `MAX`: Minimum and maximum function values. Must be numbers, with `MIN` less than `MAX`. The wider the range between these values, the longer mesh generation will take.
- `STEP`: The step size for mesh generation. Must be a number and should be less than `MAX` - `MIN`. Values between 0.01 and 0.5 work well. The smaller the value, the longer mesh generation will take.
- `ISO`: The threshold value determining when a point is inside the object. Must be a number. For the default function provided with the code, this value is the radius of the generated sphere.
- `MODE`: The mode for mesh generation. Must be one of `f`, `x`, `y`, or `z`, where:
	- `f`: Full - the entire mesh will be generated in one pass. Faster overall generation time, but the program will be unresponsive until the complete mesh is generated.
	- `x`, `y`, `z`: Incremental - The mesh will be generated in "slices" along one of the three axes. Slower overall generation time, but you can see the mesh and move the camera as it is being generated.
		- Recommended for wide ranges and/or small step sizes. The program will warn you if generation will be slow in Full mode.

Running the program with no arguments uses the default values:
- `FILENAME`: None; the program will not generate a file.
- `MIN` and `MAX`: -2 and 2, respectively.
- `STEP`: 0.01
- `ISO`: 1
- `MODE`: z (Mesh generated incrementally along the Z axis)

Arguments must be provided in order, but later ones can be omitted (e.g. `as5 test.ply -3 3` generates a file named `test.ply` with minimum -3 and maximum 3, using the default values for `STEP`, `ISO`, and `MODE`).
- Note that `MIN` and `MAX` must be provided as a pair. Omitting `MAX` will result in the defaults being used for both `MIN` and `MAX`.
### Changing Other Parameters
By default, the program generates a sphere. To change the function used to generate the surface, change which line is uncommented in the `f` function starting at line 29 of `as5.cpp`, then recompile. In addition to the sphere function, the two functions from the assignment instructions are included. You can also add your own.

The material colour can be modified by changing `MODEL_COLOR` on line 41.
## Known Bugs
The window will become unresponsive while writing the file, which can take a while for big meshes. I added a progress indicator in the command line output so you can see how much of the file is left to write.
## Code explanation
### Structure/Classes
- Instead of having a `MarchingCubes` function which returns a vector, I made a `MarchingCubes` class which contains the generation function and maintains its own list of vertices. This made it easier to implement incremental generation since the `MarchingCubes` object can keep track of how much it has generated so far. The main function then only has to create the object once and repeatedly call `generate()` until it reports that it's finished.
- The `MarchingCubes` object supports using other comparison operators to determine which points are inside the function. I implemented this before noticing that the assignment instructions explicitly state which comparison to use, so this functionality is never actually used. If you want to mess around with it, you can change the `comp` parameter in the `MarchingCubes` constructor.
### Mesh Generation
- The `MarchingCubes::generateFull` function is a simple extension of the 2D version from the in-class demo code. The `generateIterative` function is similar, except it only uses two nested loops since it generates a single slice each time it's called.
- `generateIterative` only has two nested loops with iteration variables `a` and `b`, and assigns them to axes depending on which generation mode is selected. This reduces the total lines of code needed vs. the alternative of having a separate pair of loops for each mode.
	- For example, when generating over the Z axis, `a` is assigned to the X axis and `b` is assigned to the Y axis.
- I chose the "slice along an axis" method of iterative generation because it was shown in class and it worked when I tried it. Another option might have been to split the generation volume into cubic "chunks" and run Marching Cubes over each one individually.
### Rendering
- The code to draw the axes was shamelessly ripped out of class demo code.
- The shaders are based on the provided demo code and the code from the lecture note, with some modifications to account for directional instead of point light in the vertex shader.
- `DYNAMIC_DRAW` mode was used for the VBOs since they are repeatedly modified when incremental mesh generation is used.
### File Output
- The `writePLY` function is pretty simple. It writes the header according to the sizes of the two lists passed in, then just writes out the entire contents of both lists to the file.
- I added a basic progress indicator that prints to standard output after every 10K lines so you can tell how long writing the file will take. (otherwise, for big meshes, it might seem like the program has crashed)
### Camera movement
- I added the delta time code from an in-class demo to keep the camera movement speed consistent between while the mesh is generating (low frame rate) and after it's done (high frame rate).
